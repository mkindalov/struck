{"name":"Struckture","tagline":"Binary structure reader for Java","body":"[![Circle CI](https://circleci.com/gh/mkindalov/struckture.svg?style=svg)](https://circleci.com/gh/mkindalov/struckture)\r\n[![Build Status](https://travis-ci.org/mkindalov/struckture.svg?branch=master)](https://travis-ci.org/mkindalov/struckture)\r\n### Target\r\nThis java framework is for those who want to read binary structures in java. Useful for reverse engineering of file formats.\r\n\r\n### Licence\r\n[Apache Licence version 2](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\n### Documentation\r\n#### Usage\r\nYou need an annotated class representing the structure to read:\r\n``` java\r\n    @Struckture(length = 10) \r\n    public class Structure {\r\n        @StruckField(offset = 0)\r\n        int field1;\r\n    }\r\n```\r\n\r\nThe reading from file goes like this: \r\n``` java\r\n    InputStream stream = new FileInputStream(\"filename\");\r\n    Struck<Structure> struck = Strucktor.forClass(Structure.class);\r\n    Structure structure;\r\n    while((structure = struck.read(stream)) != null) {\r\n        //do something\r\n    }\r\n```\r\n#### `@Struckture(length = 0x10)`\r\nThe structure to read must be annotated with `@Struckture` annotation with the `length` in bytes specified. The framework then tries to read chunks of `length` bytes and resolve them into a structure.\r\n\r\n#### `@StruckField`\r\nStruckture framework process a field only if it is annotated with `@StruckField`.\r\n``` java\r\n    @Struckture(length = 0x10)\r\n    private static class Structure {\r\n        @StruckField(offset = 0x3)\r\n        private int processed;\r\n        \r\n        private int notProcessed; //always 0\r\n    }\r\n```\r\n`offset` is the only common attribute for all field mappings. It sets the position(in bytes) of the read chunk from which to read the field. `(offset = 0)` means read from the start.\r\n\r\n`size` attribute is optional and ignored if not needed. It is useful for reading bytes, bit arrays and strings.\r\nFor example:\r\n``` java\r\n        @StruckField(offset = 0x3)\r\n        private int defaultSizeFour;\r\n    }\r\n```\r\nWhen reading int, starting the offset the next 4 bytes are used in defining the field value. This is because the int size is 4.\r\nThe list goes like this:\r\n\r\n| Type | Size(bytes) | Type | Size(bytes) |\r\n| ---- | ---- | ---- | ---- |\r\n| `boolean` | 1 | `Boolean` | 1 |\r\n| `byte` | 1 | `Byte` | 1 |\r\n| `short` | 2 | `Short` | 2 |\r\n| `int` | 4 | `Integer` | 4 |\r\n| `long` | 8 | `Long` | 8 |\r\n| `float` | 4 | `Float` | 4 |\r\n| `double` | 8 | `Double` | 8 |\r\n| `byte[]` | `size` attribute | `boolean[]` | `size` attribute |\r\n| `String` | Check the [strings section](#reading-strings)| | |\r\n\r\n#### `@Reverse`\r\nIf `@Reverse` annotation is used then instead of **BigEndian** the value will be resolved as **LittleEndian**\r\n```java\r\n        @StruckField(offset = 0x8) @Reverse\r\n        private int reverse;\r\n```\r\nThis Annotation will influence on all primitives and wrappers with size > 1 and byte[].\r\n\r\n#### `@BitPosition`\r\nWhen reading `boolean` the value is resolved in the following way: `value = byte[offset] > 0`\r\nIf we want to get the value of a bit in that byte then we use `@BitPosition` annotation. \r\n\r\n```java\r\n        @StruckField(offset = 0xa)\r\n        private boolean trueIfByteGreaterThan0;\r\n        @StruckField(offset = 0xf) @BitPosition(3)\r\n        private boolean trueIfBit3IsSet;\r\n```\r\n\r\n#### Reading Strings\r\nWhen reading strings `size` means `maxSize`. When reading `String` with size 5, the result will have length between 0 and 5.\r\nEncoding can be changed using `@StringEncoding()` annotation. Default encoding is **\"ASCII\"**\r\n```java\r\n        @StruckField(offset = 0x2, size = 5)\r\n        private String string;\r\n\r\n        @StruckField(offset = 0, size = 0x11) @StringEncoding(\"utf-8\")\r\n        private String utf8string;\r\n```\r\n\r\n#### `AllowOverlapping`\r\nWhen `@Struckture(allowOverlapping = true)` is used, the check if multiple fields depend on the same bytes is disabled, so same bytes can be used in different fields. In the next example bytes 4, 5, 6, 7 are used for the integer and byte[]\r\n```java\r\n    @Struckture(length = 0x8, allowOverlapping = true)\r\n    private static class OverlappingAllowedStructure {\r\n        @StruckField(offset = 4)\r\n        private int integer;\r\n        @StruckField(offset = 4, size = 4)\r\n        private byte[] bytes;\r\n    }\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}